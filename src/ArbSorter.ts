/*
 * Copyright (c) 2021-2022 William Baker
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

/**
 * This class represents a sequence of grapheme clusters. It may not work in the
 * general case (esp. for whitespace) but it at least handles combining
 * diacritics and ZWJ.
 */
class GraphemeString {
    /**
     * The list of all grapheme clusters in the string, expanded by
     * String#normalize('NFD').
     */
    readonly clusters: string[];

    constructor(str: string) {
        this.clusters = [];
        let current = '';

        for (const char of str) {
            if (
                current === ''
                || /^\p{Mn}$/u.test(char) // nonspacing mark
                || char === '\u200D' // ZWJ
            ) {
                current += char;
            } else {
                this.clusters.push(current.normalize('NFD'));
                current = char;
            }
        }

        this.clusters.push(current.normalize('NFD'));
    }

    /**
     * @returns A string visually equivalent to the one used to construct this,
     * but not necessarily equal to it.
     */
    toString() {
        return this.clusters.join('');
    }

    /**
     * Determine whether one string starts with another, comparing grapheme
     * clusters rather than code units.
     * @param other The (shorter) string to search for.
     * @returns `true` if this string starts with (or is equivalent to) other;
     * `false` otherwise.
     */
    startsWith(other: GraphemeString) {
        if (this.clusters.length < other.clusters.length) {
            return false;
        }
        for (let i = 0; i < other.clusters.length; ++i) {
            if (this.clusters[i] !== other.clusters[i]) {
                return false;
            }
        }

        return true;
    }
}

/**
 * This class represents a sorting mechanism that can use an arbitrary sort
 * order. Its main purpose is to alphabetize the output of Lexifer.
 */
class ArbSorter {
    private readonly ords: { [key: string]: number };
    private readonly vals: string[];
    private readonly splitOrder: GraphemeString[];

    /**
     * Create a new `ArbSorter`.
     * @param order The list of all graphs used, in the order they are to be
     * sorted, separated by whitespace.
     */
    constructor(order: string) {
        const graphs = order.split(/\s+/gu).map(el => new GraphemeString(el));

        this.splitOrder = [...graphs].sort((a, b) =>
            b.clusters.length - a.clusters.length);

        this.ords = {};
        this.vals = [];

        for (const i in graphs) {
            const key = graphs[i]!.toString();
            this.ords[key] = +i;
            this.vals.push(key);
        }
    }

    /**
     * Convert a word to an array of numbers, for better sorting.
     * @param word The original word, as a string.
     * @returns A list of numbers based on the sort order.
     */
    private wordAsValues(word: string) {
        const splitWord = this.split(word);
        const arrayedWord = splitWord.map(char => this.ords[char]);
        if (arrayedWord.includes(undefined)) {
            throw new Error(`word with unknown letter: '${word}'.\n`
                + 'A filter or assimilation might have caused this.');
        }

        return <number[]>arrayedWord;
    }

    /**
     * Convert the array of numbers generated by `wordAsValues()` back to a
     * word.
     * @param values The list of numbers based on the sord order.
     * @returns The original word, as a string.
     */
    private valuesAsWord(values: readonly number[]) {
        return values.map(el => this.vals[el])
            .join('');
    }

    /**
     * Split a word into its graphs.
     * @param word The word to be split.
     * @returns An array of short strings, each one representing a single
     * grapheme or multigraph.
     */
    split(word: string): string[] {
        const wordGraphemes = new GraphemeString(word);
        const answer: string[] = [];

        while (wordGraphemes.clusters.length > 0) {
            for (const grapheme of this.splitOrder) {
                if (wordGraphemes.startsWith(grapheme)) {
                    wordGraphemes.clusters.splice(0, grapheme.clusters.length);
                    answer.push(grapheme.toString());
                }
            }
        }

        return answer;
    }

    /**
     * Sort a list of words.
     * @param list The list of words to be sorted.
     * @returns A sorted copy of the list.
     */
    sort(list: readonly string[]) {
        const l2 = list.filter(Boolean)
            .map(this.wordAsValues, this);

        l2.sort((a, b) => {
            for (let i = 0; i < Math.min(a.length, b.length); ++i) {
                if (a[i] !== b[i]) {
                    return a[i]! - b[i]!;
                }
            }

            return a.length - b.length;
        });

        return l2.map(this.valuesAsWord, this);
    }
}

export default ArbSorter;
